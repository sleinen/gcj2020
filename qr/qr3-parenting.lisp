;;; Google Code Jam 2020, Qualification Round, Problem 3: Parenting Partnering Returns

(defun solve (&optional (in *standard-input*))
  (dotimes (caseno (read in))
    (format t "Case #~D: " (1+ caseno))
    (solve-case in)))

(defstruct (graph (:constructor make-graph (N)))
  (N)
  (nodes)
  (links))

(defmethod print-object ((g graph) out)
  (declare (ignore depth))
  (print-unreadable-object (g out :type t)
    (dotimes (i (graph-N g))
      (format out "~A" (or (node-color (graph-node g i)) #\–)))
    #+foo
    (format out "with ~D nodes" (graph-N g))))

(defstruct (node)
  (S)
  (E)
  (color)
  (visited nil))

(defmethod print-object ((n node) out)
  (declare (ignore depth))
  (print-unreadable-object (n out :type t)
    (format out "~D–~D" (node-S n) (node-E n))
    (format out " ~A" (ecase (node-color n)
                        ((#\C) #\C)
                        ((#\J) #\J)
                        ((nil) #\–)))))

(defun graph-node (g i)
  (aref (graph-nodes g) i))

(defun create-graph (N)
  (let ((g (make-graph N)))
    (setf (graph-nodes g) (make-array (list N)))
    (setf (graph-links g) (make-array (list N N) :element-type 'bit :initial-element 0))
    g))

(defun bfs (g fun)
  (dotimes (i (graph-N g))
    ;(unless (node-visited (graph-node g i))
      (bfs-1 g i nil fun)));)

(defun bfs-1 (g i parent fun)
  (let ((n1 (graph-node g i)))
    (setf (node-visited n1) t)
    (funcall fun g i n1 parent)
    (dotimes (j (graph-N g))
      (let ((n2 (graph-node g j)))
        (unless (node-visited n2)
          (when (not (zerop (aref (graph-links g) i j)))
            (bfs-1 g j n1 fun)))))))

(defun compute-overlap (g)
  (let ((N (graph-N g))
        (nodes (graph-nodes g)))
    (labels
        ((overlapp (ni nj)
           (or (overlapp-1 ni nj)
               (overlapp-1 nj ni)))
         (overlapp-1 (ni nj)
           (if (<= (node-S ni) (node-S nj))
               (> (node-E ni) (node-S nj))
               (and (< (node-E ni) (node-E nj))
                    (< (node-S ni) (node-E nj))))))
      ;; detect overlaps
      (dotimes (i N)
        (let ((ni (aref nodes i)))
          (dotimes (j N)
            (let ((nj (aref nodes j)))
              (setf (aref (graph-links g) i j)
                    (if (overlapp ni nj) 1 0)))))))))

(defparameter default-color #\C)

(defun complement-color (color)
  (ecase color
    ((#\C) #\J)
    ((#\J) #\C)))

(defun solve-case (in)
  (let* ((N (read in))
         (g (create-graph N)))
    ;; read chores
    (dotimes (i N)
      (setf (aref (graph-nodes g) i) (make-node :S (read in) :E (read in))))
    ;; compute links
    (compute-overlap g)
    ;; color graph
    (bfs g #'(lambda (g i n1 parent)
               (declare (ignorable g i))
               (if (and parent (node-color parent))
                   (let ((new-color (complement-color (node-color parent))))
                     (when (and (node-color n1) (not (eq (node-color n1) new-color)))
                       (format t "IMPOSSIBLE~%")
                       (return-from solve-case))
                     (setf (node-color n1) new-color))
                   (unless (node-color n1)
                     (setf (node-color n1) default-color)))))
    (dotimes (i N)
      (let ((n1 (graph-node g i)))
        (do ((j (1+ i) (1+ j)))
            ((>= j N))
          (let ((n2 (graph-node g j)))
            (when (not (zerop (aref (graph-links g) i j)))
              (when (eq (node-color n1) (node-color n2))
                (format t "IMPOSSIBLE~%")
                (return-from solve-case)))))))
    (dotimes (i N)
      (format t "~A" (node-color (graph-node g i))))
    (format t "~%")))

(solve)
